Description: Fix selection autoscroll with maximized windows
Author: Chris Coulson <chris.coulson@canonical.com>
Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=644621
Bug-Ubuntu: https://launchpad.net/bugs/744580
Forwarded: https://bug644621.bugzilla.mozilla.org/attachment.cgi?id=525563

diff --git a/layout/generic/nsSelection.cpp b/layout/generic/nsSelection.cpp
--- a/layout/generic/nsSelection.cpp
+++ b/layout/generic/nsSelection.cpp
@@ -4720,18 +4720,20 @@ nsTypedSelection::DoAutoScroll(nsIFrame 
   nsRootPresContext* rootPC = presContext->GetRootPresContext();
   if (!rootPC)
     return NS_OK;
   nsIFrame* rootmostFrame = rootPC->PresShell()->FrameManager()->GetRootFrame();
   // Get the point relative to the root most frame because the scroll we are
   // about to do will change the coordinates of aFrame.
   nsPoint globalPoint = aPoint + aFrame->GetOffsetToCrossDoc(rootmostFrame);
 
+  nsRect rect = nsIntRect(-20, -20, 40, 40).
+    ToAppUnits(presContext->AppUnitsPerDevPixel());
   PRBool didScroll = presContext->PresShell()->
-    ScrollFrameRectIntoView(aFrame, nsRect(aPoint, nsSize(1,1)),
+    ScrollFrameRectIntoView(aFrame, rect + aPoint,
                             NS_PRESSHELL_SCROLL_ANYWHERE,
                             NS_PRESSHELL_SCROLL_ANYWHERE, 0);
 
   //
   // Start the AutoScroll timer if necessary.
   //
 
   if (didScroll && mAutoScrollTimer)
diff --git a/layout/generic/test/Makefile.in b/layout/generic/test/Makefile.in
--- a/layout/generic/test/Makefile.in
+++ b/layout/generic/test/Makefile.in
@@ -124,16 +124,17 @@ _TEST_FILES = \
 		test_bug522632.html \
 		test_bug589621.html \
 		test_bug589623.html \
 		test_bug632379.xul \
 		test_bug633762.html \
 		bug633762_iframe.html \
 		$(srcdir)/../../reftests/backgrounds/blue-32x32.png \
 		$(srcdir)/../../reftests/backgrounds/fuchsia-32x32.png \
+		test_drag_selection_autoscroll.html \
 		$(NULL)
 
 _CHROME_FILES = \
 		test_bug514732-2.xul \
 		file_bug514732_window.xul \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
diff --git a/layout/generic/test/test_drag_selection_autoscroll.html b/layout/generic/test/test_drag_selection_autoscroll.html
new file mode 100644
--- /dev/null
+++ b/layout/generic/test/test_drag_selection_autoscroll.html
@@ -0,0 +1,130 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Test for autoscrolling the selection into view, when dragging</title>
+  <script type="text/javascript" src="/MochiKit/packed.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/EventUtils.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+
+<div id="target" style="overflow:auto; width:200px; height:200px; position:absolute; top:200px; left:0;">
+  <div style="height:400px; width:400px;"></div>
+  <div><span style="display:inline-block; vertical-align:top; height:20px;">Test</span></div>
+  <div style="height:400px;"></div>
+</div>
+
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+const UP = 0;
+const DOWN = 1;
+const LEFT = 2;
+const RIGHT = 3;
+
+const SCROLLED = "scrolled";
+const NOT_SCROLLED = "not_scrolled";
+const operators = {not_scrolled: is, scrolled: isnot };
+
+var params = null;
+var iter = 0;
+var pointerDestX;
+var pointerDestY;
+
+const testMatrix = [
+  { direction: DOWN, scrollStartX: 0, scrollStartY: 0, pointerDestFromEdge: 21, duration: 50, checkType: NOT_SCROLLED },
+  { direction: UP, scrollStartX: 0, scrollStartY: 100, pointerDestFromEdge: 21, duration: 50, checkType: NOT_SCROLLED },
+  { direction: RIGHT, scrollStartX: 0, scrollStartY: 0, pointerDestFromEdge: 21, duration: 50, checkType: NOT_SCROLLED },
+  { direction: LEFT, scrollStartX: 100, scrollStartY: 0, pointerDestFromEdge: 21, duration: 50, checkType: NOT_SCROLLED },
+  { direction: DOWN, scrollStartX: 0, scrollStartY: 0, pointerDestFromEdge: 19, duration: 50, checkType: SCROLLED },
+  { direction: UP, scrollStartX: 0, scrollStartY: 100, pointerDestFromEdge: 19, duration: 50, checkType: SCROLLED },
+  { direction: RIGHT, scrollStartX: 0, scrollStartY: 0, pointerDestFromEdge: 19, duration: 50, checkType: SCROLLED },
+  { direction: LEFT, scrollStartX: 100, scrollStartY: 0, pointerDestFromEdge: 19, duration: 50, checkType: SCROLLED },
+  { direction: DOWN, scrollStartX: 0, scrollStartY: 0, pointerDestFromEdge: 0, duration: 50, checkType: SCROLLED },
+  { direction: UP, scrollStartX: 0, scrollStartY: 100, pointerDestFromEdge: 0, duration: 50, checkType: SCROLLED },
+  { direction: RIGHT, scrollStartX: 0, scrollStartY: 0, pointerDestFromEdge: 0, duration: 50, checkType: SCROLLED },
+  { direction: LEFT, scrollStartX: 100, scrollStartY: 0, pointerDestFromEdge: 0, duration: 50, checkType: SCROLLED },
+  { direction: DOWN, scrollStartX: 0, scrollStartY: 0, pointerDestFromEdge: -19, duration: 50, checkType: SCROLLED },
+  { direction: UP, scrollStartX: 0, scrollStartY: 100, pointerDestFromEdge: -19, duration: 50, checkType: SCROLLED },
+  { direction: RIGHT, scrollStartX: 0, scrollStartY: 0, pointerDestFromEdge: -19, duration: 50, checkType: SCROLLED },
+  { direction: LEFT, scrollStartX: 100, scrollStartY: 0, pointerDestFromEdge: -19, duration: 50, checkType: SCROLLED }
+]
+
+function doTest() {
+  target = document.getElementById("target");
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+  var selection = window.getSelection().QueryInterface(Components.interfaces.nsISelection2);
+  selection.collapse(target, 0);
+
+  target.scrollTop = params["scrollStartY"];
+  target.scrollLeft = params["scrollStartX"];
+
+  switch (params["direction"])
+  {
+  case UP:
+    pointerDestX = target.clientWidth / 2;
+    pointerDestY = params["pointerDestFromEdge"];
+    break;
+
+  case DOWN:
+    pointerDestX = target.clientWidth / 2;
+    pointerDestY = target.clientHeight - params["pointerDestFromEdge"];
+    break;
+
+  case LEFT:
+    pointerDestX = params["pointerDestFromEdge"];
+    pointerDestY = target.clientHeight / 2;
+    break;
+
+  case RIGHT:
+    pointerDestX = target.clientWidth - params["pointerDestFromEdge"];
+    pointerDestY = target.clientHeight / 2;
+    break;
+
+  default:
+    throw "Invalid test direction";
+    break;
+  }
+
+  window.setTimeout(function() {
+    var target = document.getElementById("target");
+    synthesizeMouse(target, target.clientWidth / 2, target.clientHeight / 2, { type: "mousedown" });
+    synthesizeMouse(target, pointerDestX, pointerDestY, { type: "mousemove" });
+
+    window.setTimeout(function() {
+      var target = document.getElementById("target");
+      synthesizeMouse(target, pointerDestX, pointerDestY, { type: "mouseup" });
+
+      if (params["direction"] == UP || params["direction"] == DOWN) {
+        operators[params["checkType"]](target.scrollTop, params["scrollStartY"], "Test + " + iter + ": checking if Y axis position changed");
+        is(target.scrollLeft, params["scrollStartX"], "Test + " + iter + ": checking if X axis position changed");
+      } else if (params["direction"] == LEFT || params["direction"] == RIGHT) {
+        operators[params["checkType"]](target.scrollLeft, params["scrollStartX"], "Test + " + iter + ": checking if X axis position changed");
+        is(target.scrollTop, params["scrollStartY"], "Test + " + iter + ": checking if Y axis position changed");
+      } else {
+        throw "Invalid test direction";
+      }
+
+      prepareNextTest();
+    }, params["duration"]);
+  }, 0);
+}
+
+function prepareNextTest() {
+  if (iter <= testMatrix.length - 1) {
+    params = testMatrix[iter++];
+
+    doTest();
+  } else {
+    SimpleTest.finish();
+  }
+}
+
+SimpleTest.waitForExplicitFinish();
+addLoadEvent(prepareNextTest);
+
+</script>
+</pre>
+</body>
+</html>


Index: firefox-19.0~a2~hg20121213r118806/js/src/ion/arm/Architecture-arm.h
===================================================================
--- firefox-19.0~a2~hg20121213r118806.orig/js/src/ion/arm/Architecture-arm.h	2012-12-13 06:04:55.000000000 +0000
+++ firefox-19.0~a2~hg20121213r118806/js/src/ion/arm/Architecture-arm.h	2012-12-13 21:27:57.510341208 +0000
@@ -10,6 +10,10 @@
 
 #include <limits.h>
 
+// gcc appears to use __ARM_PCS_VFP to denote that the target is a hard-float target.
+#ifdef __ARM_PCS_VFP
+#define JS_CPU_ARM_HARDFP
+#endif
 namespace js {
 namespace ion {
 
@@ -195,8 +199,8 @@
 
     static const uint32 WrapperMask = VolatileMask;
 
-    // d0 is the ARM scratch float register.
-    static const uint32 NonAllocatableMask = (1 << d0) | (1 << invalid_freg);
+    // d1 is the ARM scratch float register.
+    static const uint32 NonAllocatableMask = (1 << d1) | (1 << invalid_freg);
 
     // Registers that can be allocated without being saved, generally.
     static const uint32 TempMask = VolatileMask & ~NonAllocatableMask;
Index: firefox-19.0~a2~hg20121213r118806/js/src/ion/arm/Assembler-arm.h
===================================================================
--- firefox-19.0~a2~hg20121213r118806.orig/js/src/ion/arm/Assembler-arm.h	2012-12-13 06:04:55.000000000 +0000
+++ firefox-19.0~a2~hg20121213r118806/js/src/ion/arm/Assembler-arm.h	2012-12-13 21:28:41.102340433 +0000
@@ -64,8 +64,8 @@
 static const Register StackPointer = sp;
 static const Register FramePointer = InvalidReg;
 static const Register ReturnReg = r0;
-static const FloatRegister ReturnFloatReg = { FloatRegisters::d1 };
-static const FloatRegister ScratchFloatReg = { FloatRegisters::d0 };
+static const FloatRegister ReturnFloatReg = { FloatRegisters::d0 };
+static const FloatRegister ScratchFloatReg = { FloatRegisters::d1 };
 
 static const FloatRegister d0  = {FloatRegisters::d0};
 static const FloatRegister d1  = {FloatRegisters::d1};
@@ -1935,9 +1935,56 @@
     }
 };
 
-static const uint32 NumArgRegs = 4;
+static const uint32 NumIntArgRegs = 4;
+static const uint32 NumFloatArgRegs = 8;
+
+#ifdef JS_CPU_ARM_HARDFP
+static inline bool
+GetIntArgReg(uint32 usedIntArgs, uint32 usedFloatArgs, Register *out)
+{
+   if (usedIntArgs >= NumIntArgRegs)
+        return false;
+    *out = Register::FromCode(usedIntArgs);
+    return true;
+}
+
+static inline bool
+GetFloatArgReg(uint32 usedIntArgs, uint32 usedFloatArgs, FloatRegister *out)
+{
+    if (usedFloatArgs >= NumFloatArgRegs)
+        return false;
+    *out = FloatRegister::FromCode(usedFloatArgs);
+    return true;
+}
+
+static inline uint32
+GetIntArgStackDisp(uint32 usedIntArgs, uint32 usedFloatArgs, uint32 *padding)
+{
+    JS_ASSERT(usedIntArgs >= NumIntArgRegs);
+    uint32 doubleSlots = Max(0, (int32_t)usedFloatArgs - (int32_t)NumFloatArgRegs);
+    doubleSlots *= 2;
+    int intSlots = usedIntArgs - NumIntArgRegs;
+    return (intSlots + doubleSlots + *padding) * STACK_SLOT_SIZE;
+}
+
+static inline uint32
+GetFloatArgStackDisp(uint32 usedIntArgs, uint32 usedFloatArgs, uint32 *padding)
+{
+
+    JS_ASSERT(usedFloatArgs >= NumFloatArgRegs);
+    uint32 intSlots = 0;
+    if (usedIntArgs > NumIntArgRegs) {
+        intSlots = usedIntArgs - NumIntArgRegs;
+        // update the amount of padding required.
+        *padding += (*padding + usedIntArgs) % 2;
+    }
+    uint32 doubleSlots = usedFloatArgs - NumFloatArgRegs;
+    doubleSlots *= 2;
+    return (intSlots + doubleSlots + *padding) * STACK_SLOT_SIZE;
+}
+#else
 static inline bool
-GetArgReg(uint32 arg, Register *out)
+GetIntArgReg(uint32 arg, uint32 floatArg, Register *out)
 {
     if (arg < 4) {
         *out = Register::FromCode(arg);
@@ -1949,10 +1996,11 @@
 static inline uint32
 GetArgStackDisp(uint32 arg)
 {
-    JS_ASSERT(arg >= NumArgRegs);
-    return (arg - NumArgRegs) * STACK_SLOT_SIZE;
+    JS_ASSERT(arg >= NumIntArgRegs);
+    return (arg - NumIntArgRegs) * STACK_SLOT_SIZE;
 }
 
+#endif
 class DoubleEncoder {
     uint32 rep(bool b, uint32 count) {
         uint32 ret = 0;
Index: firefox-19.0~a2~hg20121213r118806/js/src/ion/arm/MacroAssembler-arm.cpp
===================================================================
--- firefox-19.0~a2~hg20121213r118806.orig/js/src/ion/arm/MacroAssembler-arm.cpp	2012-12-13 06:04:55.000000000 +0000
+++ firefox-19.0~a2~hg20121213r118806/js/src/ion/arm/MacroAssembler-arm.cpp	2012-12-13 21:35:56.938332689 +0000
@@ -2635,7 +2635,13 @@
     inCall_ = true;
     args_ = args;
     passedArgs_ = 0;
+#ifdef JS_CPU_ARM_HARDFP
+    usedIntSlots_ = 0;
+    usedFloatSlots_ = 0;
+    padding_ = 0;
+#else
     usedSlots_ = 0;
+#endif
     floatArgsInGPR[0] = VFPRegister();
     floatArgsInGPR[1] = VFPRegister();
 }
@@ -2661,6 +2667,42 @@
     ma_push(scratch);
 }
 
+#ifdef JS_CPU_ARM_HARDFP
+void
+MacroAssemblerARMCompat::passABIArg(const MoveOperand &from)
+{
+    MoveOperand to;
+    uint32 increment = 1;
+    bool useResolver = true;
+    ++passedArgs_;
+    Move::Kind kind = Move::GENERAL;
+    if (!enoughMemory_)
+        return;
+    if (from.isDouble()) {
+        FloatRegister fr;
+        if (GetFloatArgReg(usedIntSlots_, usedFloatSlots_, &fr)) {
+            enoughMemory_ = moveResolver_.addMove(from, MoveOperand(fr), Move::DOUBLE);
+        } else {
+            // If (and only if) the integer registers have started spilling, do we
+            // need to take the double register's alignment into accoun
+            uint32 disp = GetFloatArgStackDisp(usedIntSlots_, usedFloatSlots_, &padding_);
+            enoughMemory_ = moveResolver_.addMove(from, MoveOperand(sp, disp), Move::DOUBLE);
+        }
+        usedFloatSlots_++;
+    } else {
+        Register r;
+        if (GetIntArgReg(usedIntSlots_, usedFloatSlots_, &r)) {
+            enoughMemory_ = moveResolver_.addMove(from, MoveOperand(r), Move::GENERAL);
+        } else {
+            uint32 disp = GetIntArgStackDisp(usedIntSlots_, usedFloatSlots_, &padding_);
+            fprintf(stderr, "Float on the stack! (%d)\n", disp);
+            enoughMemory_ = moveResolver_.addMove(from, MoveOperand(sp, disp), Move::GENERAL);
+        }
+            usedIntSlots_++;
+    }
+}
+
+#else
 void
 MacroAssemblerARMCompat::passABIArg(const MoveOperand &from)
 {
@@ -2679,7 +2721,7 @@
 
     Register destReg;
     MoveOperand dest;
-    if (GetArgReg(usedSlots_, &destReg)) {
+    if (GetIntArgReg(usedSlots_, 0, &destReg)) {
         if (from.isDouble()) {
             floatArgsInGPR[destReg.code() >> 1] = VFPRegister(from.floatReg());
             useResolver = false;
@@ -2695,6 +2737,7 @@
         enoughMemory_ = enoughMemory_ && moveResolver_.addMove(from, dest, kind);
     usedSlots_ += increment;
 }
+#endif
 
 void
 MacroAssemblerARMCompat::passABIArg(const Register &reg)
@@ -2723,7 +2766,12 @@
 MacroAssemblerARMCompat::callWithABI(void *fun, Result result)
 {
     JS_ASSERT(inCall_);
-    uint32 stackAdjust = ((usedSlots_ > NumArgRegs) ? usedSlots_ - NumArgRegs : 0) * STACK_SLOT_SIZE;
+#ifdef JS_CPU_ARM_HARDFP
+    uint32 stackAdjust = ((usedIntSlots_ > NumIntArgRegs) ? usedIntSlots_ - NumIntArgRegs : 0) * STACK_SLOT_SIZE;
+    stackAdjust += 2*((usedFloatSlots_ > NumFloatArgRegs) ? usedFloatSlots_ - NumFloatArgRegs : 0) * STACK_SLOT_SIZE;
+#else
+    uint32 stackAdjust = ((usedSlots_ > NumIntArgRegs) ? usedSlots_ - NumIntArgRegs : 0) * STACK_SLOT_SIZE;
+#endif
     if (!dynamicAlignment_)
         stackAdjust +=
             ComputeByteAlignment(framePushed_ + stackAdjust, StackAlignment);
@@ -2750,8 +2798,12 @@
     ma_call(fun);
 
     if (result == DOUBLE) {
+#ifdef JS_CPU_ARM_HARDFP
+        as_vmov(ReturnFloatReg, d0);
+#else
         // Move double from r0/r1 to ReturnFloatReg.
         as_vxfer(r0, r1, ReturnFloatReg, CoreToFloat);
+#endif
     }
 
     freeStack(stackAdjust);
Index: firefox-19.0~a2~hg20121213r118806/js/src/ion/arm/MacroAssembler-arm.h
===================================================================
--- firefox-19.0~a2~hg20121213r118806.orig/js/src/ion/arm/MacroAssembler-arm.h	2012-12-13 06:04:55.000000000 +0000
+++ firefox-19.0~a2~hg20121213r118806/js/src/ion/arm/MacroAssembler-arm.h	2012-12-13 21:34:49.638333885 +0000
@@ -321,6 +321,11 @@
     // the initial number of arguments declared was correct.
     uint32 passedArgs_;
 
+#ifdef JS_CPU_ARM_HARDFP
+    uint32 usedIntSlots_;
+    uint32 usedFloatSlots_;
+    uint32 padding_;
+#else
     // ARM treats arguments as a vector in registers/memory, that looks like:
     // { r0, r1, r2, r3, [sp], [sp,+4], [sp,+8] ... }
     // usedSlots_ keeps track of how many of these have been used.
@@ -328,6 +333,7 @@
     // can effectively use between one and three slots depending on its size and
     // alignment requirements
     uint32 usedSlots_;
+#endif
     bool dynamicAlignment_;
 
     bool enoughMemory_;
